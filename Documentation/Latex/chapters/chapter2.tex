\chapter{Arhitectura platformei}
Fiind pus in fata cu provocarea de a elabora o platforma web destinata atat auditorilor publici cat si reprentatilor institutiilor din administratia publica, a fost nevoie de o arhitectura dinamica, modulara si usor de marit in cazul adaugarii a noi functionalitati.\\
De asemenea, un numar mare de functionalitati necesita implementarea si a diferite \textit{design pattern-uri}, care se asigura ca modulule definite comunica intr-un mod cat mai eficient intre ele si promoveaza reutilizarea codului deja scris.\\
Acest capitol incearca sa descrie motivatia pentru alegerile facute in materie de tehnologii folosite pentru a dezvolta componentele cheie ale aplicatiei: frontend, backend stocarea datelor si cateva aspecte legate de securitatea de baza a platformei; cat si o comparatie sumara intre potentialii competetitori ai alegerilor facute.

\section {Arhitectura generala}
Arhitectura generala a fost gandita de la inceput intr-un mod care permite adaugarea de noi functionalitati in aplicatie fara a deteriora structura sau functionalitatile deja implementate.\\
Acestea fiind zise, proiectul este impartit in doua mari componente (client si server)  care comunica intre ele prin intermediul \textit{request-urilor HTTPS} ,si anume:

\begin{itemize}
	
	\item componenta de server, este alcatuita din diferite \textit{endpoint-uri}  Web API care ofera functionalitati clientilor sai, aceasta comunicand si cu mediul de stocare al datelor, o baza de date MySQL;
	
	\item componenta client, sau interfata grafica a platformei, este o aplicatie web interactiva de tipul SPA (\textit{Single page application}), oferind functionalitatile descrise prin intermediul \textit{request-urilor} catre server, urmand ca mai apoi sa fie afisate pe pagina web prin intermediul \textit{WebAssembly};
\end{itemize}  

\section{Arhitectura serverului}

\subsection*{Arhitectura \textit{monolith}}

Arhitectura generala a serverului este una de tip \textit{monolith} traditional, impartita pe module, cu dependente slabe intre ele, care comunica intre prin intermediul unor contracte (interfete) bine definte.\\
Alegerea acestui tip de arhitectura a fost motivata de mai multe avantaje cheie ale acesteia: 
\begin{itemize}
	\item simplitatea dezvoltarii in cadrul arhitecturii de tip monolith permite lucrul pe o singura baza de cod , ceea ce simplica major procesul de dezvoltare, testare si de depistare a erorilor, fiind esentiala in fazele de inceput al unui proiect;
	
	\item  performanta sporita in cadrul unui aplicatii care raspunde \textit{request-urilor}, astfel un singur \textit{API} poate raspunde la toate cererile, eliminand nevoia de a activa si alte \textit{API-uri} externe pentru indeplinirea sarcinii, ca in cazul arhitecturii de micro-servicii;
	
	\item usurinta testarii de tip \textit{unit-testing} cat si \textit{integration-testing} intrucat toate modulele sunt in acelasi loc;
	
	\item  depistarea erorilor si rezolvarea lor este mult mai rapida;
\end{itemize}
Ca in orice alegere pe care o facem, trebuie sa punem in balanta avantajele si dezavantajele pe care aceasta le ofera si sa le comparam strict cu nevoile si problemele pe care incercam sa le rezolvam. Privind in ansamblu si pe termen lung, arhitectura de tip \textit{monolith} prezinta si ea unele dezavantaje : 

\begin{itemize}

 \item dezvoltarea incetinita in momentul in care functionalitatile pe care dorim sa le implementam cresc ca si numar, intrucat toate modulele sunt comasate intr-un singur loc;
 
 \item \textit{scalabilitate redusa} datorita stransei legaturi dintre componentele prezente in aplicatie;
 
 \item 	orice schimbare adusa in materie de noi functionalitati necesita lansarii intregii aplicatii, nu doar a unui singur modul;

\end{itemize}

Pentru a diminua efectele negative pe care aceste dezavantaje le au asupra intregului proces de dezvoltare a aplicatiei, am incercat implementarea diferitelor solutii in materie de arhitectura, \textit{desing pattern-uri} cretionale, arhitecturale cat si a numeroase practici bune comune in scrierea si mentenanta codului.

\subsection*{Arhitectura \textit{Clean Code}}
Arhitectura \textit{Clean Code } este bazata pe ideea principala precum ca stratul de logica interna (\textit{business layer}) este situat central in diagrama circulara, astfel acesta este protejat de schimbari externe. Aceasta proprietate poate fi reformulata astfel incat se defineste \textbf{Regula Dependintei} care presupune ca dependintele pot sa fie orientate doar inspre interiorul cercului, astfel niciunul din modulele interioare nu ar trebui sa fie legat in orice fel de un modul exterior acestuia.\\

---INSERT PIC HERE --- \\

Adoptarea acestui tip de arhitectura impreuna cu cea de tip \textit{monolith} include mai multe beneficii cum ar fi:

\begin{itemize}

	\item mentenanta sporita datorata faptului ca modulele sau straturile principale ale aplicatiei si logica ce le faciliteaza comnunicarea eficienta sunt separate, incurajand astfel si o intelegere mai detaliata si simplificata a intregului sistem;
	
	\item flexibilitate din punct de vedere al schimbarii tehnologiilor exterioare, stratul de logica interna este independent de ceea ce se intampla in exteriorul sau;
	
	\item testarea componentelor se poate face atat individual cat si in relatie cu alte module, astfel eliminand nevoia de testare a intregii aplicatii;
	
	\item stratul de logica interna este independent de baza de date folosita, asftel serverul de stocare al datelor poate fi schimbat cu usurinta;

\end{itemize} 
Modul in care arhitectura de tip \textit{Clean Code} a fost implementata in aceste proiect consta in separarea straturilor aplicatiei, astfel incat avem:

\begin{itemize}
	\item  \textit{Core Layer} fiind structura principala ce confera logica interna a aplicatiei.Acesta cuprinde \textit{Domain} unde sunt modelate entitatile aplicatiei respectiv \textit{Application} unde este definita toata logica interna a serverului,
	de la declaratiile abstracte ale interfetelor la definerea serviciilor proprii de care se vol folosi ulterior straturile externe ale arhitecturii;
	
	\item \textit{API Layer} este partea structurala care defineste \textit{endpoint-urile} aplicatiei prin diferite \textit{controllere}, expunand astfel functionalitatile aplicatiei la internet;
	
  	\item \textit{UI Layer} defineste structura de prezentare a aplicatiei si este formata din parte de \textit{Frontend} a aplicatiei;
  
 	 \item \textit{Infrastructure Layer} in care gasim logica ce se ocupa de comunicarea cu serviciile externe cum ar fi baza de date, AWS sau servicii de identitate;
 	 
\end{itemize}

\subsection*{\textit{Design pattern-uri} utilizate}

\textit{Design pattern-urile}, potrivit definitiei, sunt solutii generale si reutilizabile asupra problemelor comune ce pot aparea in decursul dezvoltarii unei aplicatii software.\\
Utilizare lor conduce la o buna mentananta a codului scris, posbilitatea de a reutiliza module deja scrise, imbunatateste comunicare si legaturile dintre module si incurajeaza un stil de cod cat mai elegant si usor de inteles.\\
In implementarea aplicatiei au fost folosite \textit{desing pattern-uri} din diferite categorii astfel incat in aceasta subsectiune se vor discuta cateva exemple utilizate.

\subsection*{\textit{Optional pattern}}
Acesta este un model de proiectare care ajuta la gestionarea valorilor care pot sau nu fi prezente, astfel avand valoarea \textit{null}. \textit{Pattern-ul} se asigura ca este eliminata valoarea \textit{null}, care de cele mai multe ori este o sursa comuna in erori la rularea codului (\textit{runtime}).\\
Solutia prezentata de acest model este crearea unei clase \textit{template} care incapsuleaza valoarea propriu zisa a entitatii pe care o construim. Spre exemplu, in cazul in care vrem sa cream o noua entitate de tipul \textit{User} dar la \textit{runtime} apare o eroare, executia programului nu se va opri, iar valoarea entitatii va fi incapsulata intr-un tip   \textit{Result\textless User\textgreater}

 cu parametrul \textit{Succes} setat pe fals, indicand astfel ca procesul de creare a esuat.\\

--INSERT PIC HERE --\\

\subsection*{\textit{Mediator pattern}}
Acest \textit{design pattern} este unul de tip comportamental si se asigura ca nu exista dependinte haotice intre entitatile/clasele din codul scris. Modelul restrictioneaza comunicarea directa intre obiecte si le obliga sa interactioneaze doar prin intermediul unui \textit{mediator}.\\
Acest model este implementat prin utilizarea unei interfate sau clase abstracte care stie toate referintele la componentele care vor sa comunice.In acest mod, in loc sa trimita solicitari directe, un obiect comunica prin intermediul mediatorului, acesta stiind unde sa redirectioneaze cererea.\\


--INSERT PIC HERE --

	
\subsection*{\textit{Command pattern}}	
Acest \textit{design pattern} este de asemenea unul de tip comportamental si se utilizeaza partial de \textit{design pattern-ul Mediator}, transformand astfel o comanda, spre exemplu o cerere de creare a unei noi entitati, intr-un obiect independent, acesta ulterior fiind trimis catre mediator si executat in \textit{handler-ul} corespunzator acestuia, de obicei numit \textit{receiver}.\\
In contextul dezvoltarii partii de server a aplicatiei AudIT, acesta este utiliat, impreuna cu modelul Mediator pentru a delega orice comanda (\textit{request}) primita catre obiectul care stie sa o execute. In acest mod, se elimina dependinte stranse intre obiecte, promovand un cod cat mai bine organizat si elegant.\\

--INSERT PIC HERE -- \\


\subsection*{\textit{Repository pattern}}

Folosit in special in dezvoltarea aplicatiilor web, acest \textit{design pattern} separa logica interna a aplicatiei de accesul direct la date (baza de date).Acesta se utilizeaza de interfate pentru a crea un strat separator intre declararea abstracta a acestor constracte si implementarea concreta a functiilor care acceseaza datele la nivel de baza.\\
Prin acest model, comunicarea dintre module se realizeaza prin intermediul contractului foarte bine stabilit, astfel eliminand posibilitatea ca un modul abstract sa acceseze direct un modul de acces de date.\\

--INSERT PIC HERE --\\

\subsection*{Tehnologii utilizate}


\section{Arhitectura interfatei grafice}

adasd
\section{Stocarea datelor}

\section{Aspecte de securitate}

adasd